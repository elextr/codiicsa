:max-width: 40em
Codiicsa - Asciidoc Reversed
============================
Lex Trotman
v0.1 13 June 2011

Introduction
------------

Codiicsa is an extendable Python program for converting Docbook XML to the
Asciidoc markup language.

By default it is configured to reverse Docbook with the conventions used in 
Docbook generated by Asciidoc but configuration will usually be needed for 
documents using other conventions.

Codiicsa is in its initial stages of development but so far it converts 
nested sections, simple lists, some text markup and some blocks.

Codiicsa outputs the tags for XML that it doesn't understand to indicate 
where manual editing is needed.

NOTE: Codiicsa outputs the tags and contents for unrecognised elements, but 
not the attributes of those elements.

Usage
-----

----
python codiicsa.py infile outfile
----

Design Notes
------------

Codiicsa operates by parsing the input Docbook into a tree and then generates 
the output during a depth-first tree walk.  The output is kept in memory so that
the processing for a node can edit the output of its children if needed.

Peculiarities of ElementTree
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Codiicsa uses the ElementTree parser which has some particular impacts on 
the processing of the resulting tree.  The contents of each XML element is 
stored as:

* the initial text in the _text_ attribute on the node representing the 
element, and
* a list of child nodes.

Text between the child nodes which is actually part of the text in _elem_ is 
contained in the _tail_ attributes on the child nodes.

If _elem_ represents a node which does not contain text (either by Docbook 
rules or by convention) then the _tail_ attributes can be ignored since they 
are just whitespace to make the Docbook look nice (Asciidoc generates a lot 
of this).

But if _elem_ represents a node that can contain text care must be taken to 
ensure that the when _elem_ is processed the _tails_ of its *children* are 
processed.  The _tail_ of _elem_ itself is outside its closing tag and is not
part of its processing.

Attributes of _ElementTree_ that can be useful in your processing:

* elem._text_ contains the text as described above. 

* elem._tail_ contains text following the elements close tag.

* elem.__get( 'name' )__ gets the XML attribute value for the attribute 
_name_ or _None_ if the element doesn't have that attribute.

The _Out_ class
~~~~~~~~~~~~~~~

Codiicsa accumulates its output as a list of strings rather than catenating 
it into a single string since Python string handling might generate a whole 
new string each time a modification is made (or it might not, depends on 
exact circumstances).

The _Out_ class is a convenience wrapper for a list that makes it simpler to add
strings, and _Out_ objects, eg those returned from processing child nodes.

The _Out_ constructor takes either a string or a list of strings as the initial 
list of strings.

_Out_, and string objects can be combined using the _+_ operator making it 
convenient to express a sequence of output, for example the code to generate 
the Asciidoc link syntax:

----
<<target,text>>
----

from the XML

----
<link linkend="target">text</link>
----

is

[source,python]
----

out = Out( '<<' ) + elem.get( 'linkend' ) + ',' + elem.text \
      + self.Children( elem ) + '>>' + elem.tail

----

Note that if the first item had not been made into an _Out_ object it would 
still have worked but the first four items ( '<<', the 'linkend' attribute 
value, the ',' and the elements text) would have been catenated into a 
single string first by the standard Python _+_ operator before prepending 
that string to the _Out_ object returned from processing the children.

Because the _+_ operator works for _Out_ objects, Python makes the _+=_ work as
well, so the following appends to _out_.

----
out += 'blah blah' + elem.text
----

Configuration
-------------

Codiicsa is designed to be extended or modified without changing the original 
code.  This means that you do not have to attempt to merge your changes if bug
fixes or extensions are made to the original Codiicsa.

Please read the design notes section, this provides some useful information 
to understand the process.

Codiicsa specifies all processing using a Python class with methods 
named to match the Docbook element names.  When an element is 
processed the appropriately named method is called with the element 
tree node representing the docbook element as its parameter.

[NOTE]
The preceding paragraph is the key point, method names *match* docbook 
element names, thats how it finds them, so the case must match as well.

This allows extension or overriding in the way that cascading style sheets 
or the Asciidoc configuration files work.  Methods in a child class are added
to the class or override an existing method of the same name.  You don't need 
to change the original to configure it.

As a concrete (but silly) example lets output 'bibliorefs not handled' when a
_<biblioref>_ element is seen and lets override the existing _<link>_ element 
processing to output 'links are good'.

This example will also serve to introduce a couple of other pieces of necessary
boilerplate.

The user python file (say my_file.py) is:

[source,python]
----
import codiicsa # <1>
import sys # to get the command line args

class my_stuff( codiicsa.docbook_article ) : # <2>

    def __init__( self, *args ) :
        codiicsa.docbook_article.__init__( *args ) # <3>
    
    def biblioref( self, elem ) :
        return Out( 'bibliorefs not handled' )
        
    def link( self, elem ) :
        return Out( 'links are good' )

codiicsa.convert( sys.argv[1], sys.argv[2], my_stuff ) # <4>
----

<1> Put the codiicsa.py file in the same directory so Python can find it to 
import

<2> Derive your extension from the appropriate document type class, here article

<3> Boilerplate to pass initial parameters to the base classes without caring how 
many there are, use keyword arguments if you need to add your own initial 
parameters. See below for standard parameters.

<4> Call the convert routine passing the input file name, the output file 
name and the name of your class.

This configuration file overrides the standard Codiicsa processing of _<link>_ and
adds processing for _<biblioref>_ which is not currently processed.

The program is then used by:

----
python my_file.py infilename outfilename
----

Adding top level elements
~~~~~~~~~~~~~~~~~~~~~~~~~

Codiicsa currently only supports the article top level element, but you 
can add support for others.

Classes defining top level elements must be derived from 
codiicsa.docbook_common instead of codiicsa.docbook_article.

The class must have a method for the new top level element eg _book_ and
for any specific contained elements you want to process, eg _bookinfo_.

You have to set the initial value for the section level counter so that
the correct underlining is used for section titles (see __docbook_article.article()__ ).

[[parameters]]
Constructor Parameters
~~~~~~~~~~~~~~~~~~~~~~

The constructors of Codiicsa base class codiicsa.docbook_common and docbook.article have the 
following parameters.

----
codiicsa.classname( tree, all_ids = False )
----

_tree_:: is the tree generated by ElementTree. Used to generate the 
dictionary of child to parent links.

__all_ids__:: specifies if _Pre_ (see below) ignores ids that start with underscore.

Library Methods
---------------

Codiicsa provides a set of processing methods (ie you call them with self.name)
that provide common processing capabilities.

All names begin with an uppercase to minimise clashes with methods named for 
tag names.  If tag names do clash call the library method by:

[source,python]
----
self.Processing.method( ... )
----

Pre
~~~

[source,python]
----
self.Pre( elem, inline = False, attrs = [] )
----

Generate prefix markup based on attributes of _elem_. Generates:

__\[[id]]__:: Based on the _id_ attribute.  Ids starting with underscore are 
ignored on the assumption that they are machine generated and will be re-generated.
The __all_ids__ initialisation parameter controls this behavior.

__[attrs, role=...]__:: Outputs a comma separated list of the positional 
attributes passed as _attrs_ and the _role_ attribute if it is present on 
the element.

The _inline_ parameter controls whether the __\[[id]]__ is inline or on a 
line by itself.

Process
~~~~~~~

[source,python]
----
self.Process( elem )
----

Process the specified element to an _Out_ object.  Only used if out of order 
processing is required.

NOTE: Use __self.Children()__ to process children.

Children
~~~~~~~~

[source,python]
----
self.Children( elem, do = None, dont = set() )
----

Process the children of _elem_.

_do_:: specifies the tags names of the children to process.  the values can be:
    _None_::: (default) all children
    a string::: just process children of that tagname
    a set::: just process children with tagnames in the set

_dont_:: if _do_ is _None_ (ie all) _dont_ is a set specifying exceptions.

returns:: an _Out_ object

Strip, Stripl, Stripr
~~~~~~~~~~~~~~~~~~~~~

[source,python]
----
self.Strip( from, chars )
self.Stripl( from, chars )
self.Stripr( from, chars )
----

Remove unwanted characters from both ends of the output. _Strip_ removes from
both ends, _Stripl_ removes from the start (left) end and _Stripr_ removes from
the end (right) end.

_from_:: String, list or _Out_ object to be stripped.

_chars_:: A string specifying a set of characters to remove.

returns:: An _Out_ object with a single string.

NOTE: Works by catenating the input to a single string then stripping it.

Underline_title
~~~~~~~~~~~~~~~

Generates an Asciidoc underlined title from the _<title>_ child of the element.
The underline character used is chosen from the current _<section>_ nesting level.

[source,python]
----
self.Underline_title( elem )
----

returns:: an empty _Out_ if there is no _<title>_ child or one containing the title.

NOTE: Since __Underline_title__ has already processed the _<title>_ child subsequent
processing of the children of this element should specify __dont='title'__.

Block_title
~~~~~~~~~~~

Generates an Asciidoc block title from the _<title>_ child of the element.
[source,python]
----
self.Block_title( elem )
----

returns:: an empty _Out_ if there is no _<title>_ child or one containing the title.

NOTE: Since __Blockline_title__ has already processed the _<title>_ child subsequent
processing of the children of this element should specify __dont='title'__.

Library Functions
-----------------

The library functions are not members of a class so they are called conventionally.
Since they can't clash with tag names they have lower case names.

convert
~~~~~~~

Use the specified class to convert the input file to the output file.

[source,python]
----
convert( infile, outfile, \
         dbclass = None, cargs = [], kcargs = {}, \
         cwsl = True )
----

_infile_:: Filename of the input docbook file.

_outfile_:: Filename to write the Asciidoc to, overwrites existing files.

_dbclass_:: The name of the class to use for the conversion processing.  If 
_None_ (the default) one of the standard classes is used based on the docbook 
root element type.

_cargs_:: List of parameters to be passed to the dbclass constructor (see 
<<parameters>>) in addition to the tree.

_kcargs_:: Dictionary of keyword parameters to be passed to the dbclass constructor.

_cwsl_:: Crush whitespace lines (see below).

For readability Docbook is often formatted with nested tags separated by 
newlines and indented so that they look like:

----
<articleinfo>
    <title>AsciiDoc User Guide</title>
    <author>
        <firstname>Stuart</firstname>
        <surname>Rackham</surname>
        <email>srackham@gmail.com</email>
    </author>
    <authorinitials>SJR</authorinitials>
</articleinfo>
----

When an element can contain text, technically this whitespace is part of the 
element, but it produces a lot of whitespace lines in the Asciidoc output.

When _cwsl_ is true (the default) contiguous whitespace lines are reduced to 
a single blank line since in Asciidoc more than one is redundant.  If you 
have literal elements with multiple blank lines this may be annoying, _cwsl_ 
can be set to _False_ to prevent crushing, but the effort to hand edit the 
literal is likely to be much less than editing the amount of redundant 
whitespace produced.  
